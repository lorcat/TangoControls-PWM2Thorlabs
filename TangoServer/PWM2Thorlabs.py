#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        PWM2Thorlabs.py
#
#  Project :     
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      konstantin.glazyrin$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["PWM2Thorlabs", "PWM2ThorlabsClass", "main"]

__docformat__ = 'restructuredtext'

import json

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(PWM2Thorlabs.additionnal_import) ENABLED START -----#

import requests
import re
import time
import copy
import threading
import queue

import tango as PyTango

class Worker(threading.Thread):
    """
    Threading class with major tasks - communicating, status setting
    """
    K_CH = "CH"
    K_CHONOFF = "CH_ONOFF"
    K_CHONOFFSTATE = "CH_ONOFFSTATE"
    K_CHONOFFSTATECOMERR = "K_CHONOFFSTATECOMERR"

    CH_OFF = 0
    CH_ON = 1

    # tick interval and different polling times for different operation modes
    POLL_TICK = 0.2
    POLL_NORMAL = 1.0
    POLL_FAULT = 3.0

    # request pattern for retrieving and setting values
    PATTERN_HTTP_GETVALUES = "{}/pwms"
    PATTERN_HTTP_SETVALUE = "{}/pwm/{}?{}"

    # SCALERS to convert value to esp32 format
    ESP32_MIN = 0.
    ESP32_MAX = 1023.
    TS_MIN = 0.
    TS_MAX = 255.

    def __init__(self, parent, channel: int, qmsg: queue.Queue, http_address: str):
        """
        Initializes internal structure
        :param parent: object() - tango server instance
        :param qmsg: queue.Queue() - message queue to pass to the device
        :param http_address: str() - http address of the device to contact
        :param channels: channels to consider as channel 2 and 4 references
        """
        threading.Thread.__init__(self)
        self.daemon = True

        # major object references - parent object and the queue for message passing
        self.parent = parent
        self.qmsg = qmsg
        self.chnum = channel
        self.http_address = http_address

        # stop thread queue
        self._qstop = queue.Queue()

        # storage for the values and their locks - value of the channel, last value for on state, on/off state
        self._storage = {self.K_CH: None, self.K_CHONOFF: None, self.K_CHONOFFSTATE: self.CH_ON,
                         self.K_CHONOFFSTATECOMERR: None}

        # off state storage - we save current value from cache to recover it later when user requests on state
        self.lock_storage = threading.Lock()
        self.lock_storage_onoff = threading.Lock()
        self.lock_error = threading.Lock()

        # state
        self.op_state = self.POLL_NORMAL

        # communication error indicator
        self._comm_error = False

        # first run
        self._bfirst_run = True

    @property
    def comm_error(self):
        res = None
        with self.lock_error:
            res = self._comm_error
        return res

    @comm_error.setter
    def comm_error(self, value):
        with self.lock_error:
            self._comm_error = value

    @property
    def storage(self):
        """
        Multithreading safe storage value
        :return:
        """
        res = None
        with self.lock_storage:
            res = copy.deepcopy(self._storage)
        return res

    @property
    def ch(self):
        res = None
        with self.lock_storage:
            res = self._storage[self.K_CH]
        return res

    @ch.setter
    def ch(self, value):
        with self.lock_storage:
            self._storage[self.K_CH] = value

    @property
    def ch_onoff(self):
        res = None
        with self.lock_storage:
            res = self._storage[self.K_CHONOFFSTATE]
        return res

    @ch_onoff.setter
    def ch_onoff(self, value):
        with self.lock_storage:
            self._storage[self.K_CHONOFFSTATE] = value

            # keep track of old values in case of communication error
            if value is not None:
                self._storage[self.K_CHONOFFSTATECOMERR] = value

    @property
    def ch_onoffcommerr(self):
        res = None
        with self.lock_storage:
            res = self._storage[self.K_CHONOFFSTATECOMERR]
        return res

    @property
    def ch_last(self):
        res = None
        with self.lock_storage:
            res = self._storage[self.K_CHONOFF]
        return res

    @ch_last.setter
    def ch_last(self, value):
        with self.lock_storage:
            self._storage[self.K_CHONOFF] = value

    def run(self):
        """
        Main workload of the worker.
        It ticks with smaller increment times to guarantee that if a value would be sent - it would be sent immediately.
        Major value reading happens with longer intervals. Otherwise the values returned are from the cached storage.
        If a device is dead - notify the parent state and change the polling time to a longer polling period.
        :return:
        """
        while True:
            ts = time.time()

            # reading cycle - fill storage, handle errors
            self.read_device()

            # waiting process - check for new messages and process them
            ticks = int(self.op_state/self.POLL_TICK)

            for i in range(ticks):
                if self.test_quit():
                    print("Worker thread has finished operation")
                    break

                # receive a message
                try:
                    tmsg = self.qmsg.get(block=False)
                    self.qmsg.task_done()

                    self.process_message(tmsg)
                except queue.Empty:
                    pass

                time.sleep(self.POLL_TICK)
            # print("Tick cycle took ({:6.2f} s)".format(time.time()-ts))

    def test_quit(self):
        """
        Quit state indication
        :return:
        """
        res = False
        try:
            self._qstop.get(block=False)
            self._qstop.task_done()
            res = True
        except queue.Empty:
            pass
        return res

    def process_message(self, msg):
        """
        Processes a message - typically setting values
        :param msg:
        :return:
        """
        # print("Processing message: {}".format(msg))

        # do not send commands if there is an issue with communication
        if self.comm_error:
            return

        if isinstance(msg, dict):
            final_state = None

            # process a channel value change or a state on/off change
            if self.K_CH in msg:
                final_state = msg[self.K_CH]

            elif self.K_CHONOFFSTATE in msg:
                value = msg[self.K_CHONOFFSTATE]

                cur_state = self.ch

                # we consider as on any positive number, let's avoid multiple on or off messages
                if value > self.CH_OFF and self.ch_onoff > self.CH_OFF:
                    return

                if value <= self.CH_OFF and self.ch_onoff <= self.CH_OFF:
                    return

                # we switch on or off
                if value > self.CH_OFF and self.ch_onoff <= self.CH_OFF:
                    # print("Switching on")
                    final_state = self.ch_last
                    if final_state is None:
                        final_state = 0

                    self.ch = self.ch_last
                    self.ch_last = None
                    self.ch_onoff = self.CH_ON

                elif value <= self.CH_OFF and self.ch_onoff > self.CH_OFF:
                    # print("Switching off")
                    final_state = self.ch = self.CH_OFF
                    self.ch_last = cur_state
                    self.ch_onoff = self.CH_OFF

            # send message if there is something to send
            if isinstance(final_state, int) or isinstance(final_state, float):

                # value should be converted from our normal style - 0-255 values to ESP32 0-1023 range
                final_state = int((self.ESP32_MAX-self.ESP32_MIN)/(self.TS_MAX-self.TS_MIN)*final_state)

                if final_state < self.ESP32_MIN:
                    final_state = int(self.ESP32_MIN)
                elif final_state > self.ESP32_MAX:
                    final_state = self.ESP32_MAX

                url = self.PATTERN_HTTP_SETVALUE.format(self.http_address, self.chnum, final_state)
                # print("Sending message: {}; {};".format(final_state, url))
                self._sent2receive(url)

    def read_device(self):
        """
        Reads from the device, fills the storage for reporting, sets state of the tango server
        :return:
        """
        url = self.PATTERN_HTTP_GETVALUES.format(self.http_address)

        bconnok = True
        data = self._sent2receive(url)

        if data:
            try:
                tdict = json.loads(data)

                tk = "{}".format(self.chnum)

                if tk in tdict:
                    value = tdict[tk]

                    value = float(value)
                    cvalue = int((self.TS_MAX-self.TS_MIN)/(self.ESP32_MAX-self.ESP32_MIN)*value)

                    if self.ch != cvalue:
                        self.ch = cvalue
                        # print("Data: {} {} {}".format(value, cvalue, threading.currentThread()))

            except json.JSONDecodeError:
                self.ch = None


    def _sent2receive(self, url):
        """
        Basic send and receive functionality with requests, handles errors
        :param url:
        :return:
        """
        res = None

        bconnok = True

        req = None
        try:
            req = requests.get(url)
        except requests.exceptions.ConnectionError:
            bconnok = False

        bpreverr = self.comm_error

        # check if we have an error with communication
        if not bconnok or not req.ok:
            self.comm_error = True

            if not bpreverr:
                try:
                    self.parent._set_state(PyTango.DevState.FAULT)
                    self.parent._set_status("Communication fault ({})".format(self.http_address))
                except AttributeError:
                    pass

                self.ch = None
                self.ch_onoff = None
                self.ch_last = None
                return res

        # we have an ok in communication
        self.comm_error = False
        if bpreverr or self._bfirst_run:
            self.parent._set_state(PyTango.DevState.ON)
            self.parent._set_status("Communication ok ({})".format(self.http_address))

            if self._bfirst_run:
               self._bfirst_run = False

            # recover from a communication error
            if self.ch_onoff is None:
                self.ch_onoff = self.ch_onoffcommerr

        # return data
        if bconnok and req.ok:
            res = req.content

        return res

    def stop(self):
        """
        Starts stop thread procedure
        :return:
        """
        self._qstop.put("quit")


#----- PROTECTED REGION END -----#	//	PWM2Thorlabs.additionnal_import

# Device States Description
# No states for this device


class PWM2Thorlabs (PyTango.Device_4Impl):
    """A controller to an Espressif ESP32-C3 controlling PWM of the device.
    PWM controls the light output of the Thorlabs LEDD1B."""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(PWM2Thorlabs.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.global_variables

    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        PWM2Thorlabs.init_device(self)
        #----- PROTECTED REGION ID(PWM2Thorlabs.__init__) ENABLED START -----#

        self._lock_status = threading.Lock()
        self._lock_state = threading.Lock()

        # set value message queue
        self.qmsg = queue.Queue()

        # start the worker and fill the properties, we start in daemon = True mode
        self.worker = Worker(self, self.pwm_channel, self.qmsg, self.http_address)
        self.worker.start()

        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(PWM2Thorlabs.delete_device) ENABLED START -----#
        if isinstance(self.worker, Worker) and self.worker.is_alive():
            self.worker.stop()
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Intensity_read = 0
        self.attr_LEDOffOn_read = 0
        #----- PROTECTED REGION ID(PWM2Thorlabs.init_device) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(PWM2Thorlabs.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.always_executed_hook

    # -------------------------------------------------------------------------
    #    PWM2Thorlabs read/write attribute methods
    # -------------------------------------------------------------------------
    
    def read_Intensity(self, attr):
        self.debug_stream("In read_Intensity()")
        #----- PROTECTED REGION ID(PWM2Thorlabs.Intensity_read) ENABLED START -----#
        self.attr_Intensity_read = self.worker.ch
        attr.set_value(self.attr_Intensity_read)
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.Intensity_read
        
    def write_Intensity(self, attr):
        self.debug_stream("In write_Intensity()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(PWM2Thorlabs.Intensity_write) ENABLED START -----#

        # sets the message to change the attribute value
        # print("Writing intensity data: {}".format(data))
        msg = {self.worker.K_CH: data}
        self.qmsg.put(msg)
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.Intensity_write
        
    def read_LEDOffOn(self, attr):
        self.debug_stream("In read_LEDOffOn()")
        #----- PROTECTED REGION ID(PWM2Thorlabs.LEDOffOn_read) ENABLED START -----#

        self.attr_LEDOffOn_read = self.worker.ch_onoff
        attr.set_value(self.attr_LEDOffOn_read)
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.LEDOffOn_read
        
    def write_LEDOffOn(self, attr):
        self.debug_stream("In write_LEDOffOn()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(PWM2Thorlabs.LEDOffOn_write) ENABLED START -----#
        print("Writing on/off data: {}".format(data))
        msg = {self.worker.K_CHONOFFSTATE: data}
        self.qmsg.put(msg)
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.LEDOffOn_write

            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(PWM2Thorlabs.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.read_attr_hardware


    # -------------------------------------------------------------------------
    #    PWM2Thorlabs command methods
    # -------------------------------------------------------------------------
    def _set_state(self, state):
        """
        Wrapper to the Tango set_state
        :param state:
        :return:
        """
        with self._lock_state:
            self.set_state(state)

    def _set_status(self, msg):
        """
        Wrapper to the Tango set_status
        :param msg:
        :return:
        """
        with self._lock_status:
            self.set_status(msg)

    #----- PROTECTED REGION ID(PWM2Thorlabs.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.programmer_methods

class PWM2ThorlabsClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(PWM2Thorlabs.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.global_class_variables


    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'http_address':
            [PyTango.DevString, 
            "HTTP Address of an esp32 device offering web server interface.",
            ["http://169.254.5.10:8080"] ],
        'pwm_channel':
            [PyTango.DevString, 
            "PWM channel to control",
            ["2"] ],
        }


    #    Command definitions
    cmd_list = {
        }


    #    Attribute definitions
    attr_list = {
        'Intensity':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "Tango Ch2 -> ESP Device Ch2",
            } ],
        'LEDOffOn':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "Tango Ch2 -> ESP Device Ch2",
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(PWM2ThorlabsClass, PWM2Thorlabs, 'PWM2Thorlabs')
        #----- PROTECTED REGION ID(PWM2Thorlabs.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PWM2Thorlabs.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)

if __name__ == '__main__':
    main()
